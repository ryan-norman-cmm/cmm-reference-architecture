# GraphQL Integration with FHIR

## Introduction

Healthcare applications often need to retrieve complex, interconnected data from multiple resources in a single request. This guide explains how to integrate GraphQL with FHIR to enable more flexible and efficient data retrieval. GraphQL provides a powerful query language that allows clients to request exactly the data they need, reducing over-fetching and under-fetching of data that is common with traditional REST APIs.

### Quick Start

1. Enable GraphQL in Aidbox by adding the appropriate configuration to your project
2. Set up a GraphQL client to communicate with the `/graphql` endpoint
3. Create queries that specify exactly the fields and related resources you need
4. Implement fragments for reusable query components
5. Consider federation for integrating FHIR data with other systems

### Related Components

- [FHIR Query Optimization](fhir-query-optimization.md): REST-based query optimization techniques
- [Accessing FHIR Resources](accessing-fhir-resources.md): Basic FHIR query patterns
- [GraphQL Architecture Decisions](fhir-graphql-decisions.md) (Coming Soon): Understand GraphQL implementation choices

## Why GraphQL for FHIR?

FHIR's RESTful API is powerful, but it has limitations when retrieving complex, nested data structures. GraphQL addresses these limitations by:

1. **Reducing Network Overhead**: Clients can request exactly the fields they need in a single query
2. **Minimizing Round Trips**: Related resources can be fetched in a single request
3. **Providing Type Safety**: The GraphQL schema ensures type-safe queries
4. **Enabling Flexible Queries**: Clients can shape the response to match their needs
5. **Supporting Real-time Updates**: Through subscriptions for event-driven applications

## Setting Up GraphQL with Aidbox

Aidbox provides built-in GraphQL support for FHIR resources. Here's how to set it up:

### Enabling GraphQL in Aidbox

To enable GraphQL in Aidbox, add the following configuration to your Aidbox project:

```yaml
# In your Aidbox configuration file (project.edn)
{:zen/tags #{aidbox/system}
 :graphql {:zen/tags #{aidbox/service}
          :engine :aidbox}}
```

This enables the GraphQL endpoint at `/graphql`.

### Basic GraphQL Client Setup

```typescript
import { AidboxClient } from '@aidbox/sdk-r4';

const client = new AidboxClient({
  baseUrl: 'http://localhost:8888',
  auth: {
    type: 'basic',
    username: 'root',
    password: 'secret'
  }
});

async function executeGraphQLQuery(query: string, variables?: any): Promise<any> {
  const response = await client.request({
    method: 'POST',
    url: '/graphql',
    data: {
      query,
      variables
    }
  });
  
  return response;
}
```

## GraphQL Schema Design for FHIR

The GraphQL schema for FHIR resources is automatically generated by Aidbox based on the FHIR resource definitions. Here's how the schema is structured:

### Resource Types

Each FHIR resource type becomes a GraphQL type with fields corresponding to the resource's attributes.

### Query Types

The root Query type includes fields for each resource type, allowing you to query resources by ID or search parameters.

### Example Schema

```graphql
type Patient {
  id: ID
  resourceType: String
  name: [HumanName]
  birthDate: String
  gender: String
  address: [Address]
  telecom: [ContactPoint]
  # ... other Patient fields
}

type HumanName {
  use: String
  family: String
  given: [String]
  prefix: [String]
  suffix: [String]
}

type Query {
  Patient(id: ID): Patient
  PatientList(name: String, birthDate: String, gender: String, _count: Int): [Patient]
  # ... other resource queries
}
```

## Basic GraphQL Queries

### Fetching a Single Resource

```typescript
async function getPatient(id: string): Promise<any> {
  const query = `
    query GetPatient($id: ID!) {
      Patient(id: $id) {
        id
        name {
          given
          family
        }
        birthDate
        gender
        address {
          line
          city
          state
          postalCode
        }
      }
    }
  `;
  
  const variables = { id };
  
  const result = await executeGraphQLQuery(query, variables);
  return result.data.Patient;
}
```

### Searching for Resources

```typescript
async function searchPatients(name?: string, gender?: string): Promise<any[]> {
  const query = `
    query SearchPatients($name: String, $gender: String) {
      PatientList(name: $name, gender: $gender) {
        id
        name {
          given
          family
        }
        birthDate
        gender
      }
    }
  `;
  
  const variables = { name, gender };
  
  const result = await executeGraphQLQuery(query, variables);
  return result.data.PatientList;
}
```

## Advanced GraphQL Patterns

### Fetching Related Resources

One of the key benefits of GraphQL is the ability to fetch related resources in a single query:

```typescript
async function getPatientWithRelatedData(id: string): Promise<any> {
  const query = `
    query GetPatientWithRelatedData($id: ID!) {
      Patient(id: $id) {
        id
        name {
          given
          family
        }
        birthDate
        gender
        # Get related Observations
        ObservationList(subject: $id) {
          id
          code {
            coding {
              system
              code
              display
            }
          }
          valueQuantity {
            value
            unit
          }
          effectiveDateTime
        }
        # Get related MedicationRequests
        MedicationRequestList(subject: $id) {
          id
          status
          medicationCodeableConcept {
            coding {
              system
              code
              display
            }
          }
          authoredOn
        }
      }
    }
  `;
  
  const variables = { id };
  
  const result = await executeGraphQLQuery(query, variables);
  return result.data.Patient;
}
```

### Using Fragments for Reusable Components

GraphQL fragments allow you to define reusable pieces of queries:

```typescript
async function getMultiplePatients(ids: string[]): Promise<any[]> {
  const query = `
    query GetMultiplePatients($ids: [ID!]!) {
      ${ids.map((id, index) => `
        patient${index}: Patient(id: "${id}") {
          ...PatientDetails
        }
      `).join('')}
    }
    
    fragment PatientDetails on Patient {
      id
      name {
        given
        family
      }
      birthDate
      gender
      address {
        line
        city
        state
        postalCode
      }
    }
  `;
  
  const result = await executeGraphQLQuery(query);
  return Object.values(result.data);
}
```

### Parameterized Queries

Use variables to create parameterized queries:

```typescript
async function getPatientsByParameters(params: {
  name?: string;
  gender?: string;
  birthDateFrom?: string;
  birthDateTo?: string;
  city?: string;
}): Promise<any[]> {
  const query = `
    query SearchPatients(
      $name: String,
      $gender: String,
      $birthDateFrom: String,
      $birthDateTo: String,
      $city: String
    ) {
      PatientList(
        name: $name,
        gender: $gender,
        birthDate: [$birthDateFrom, $birthDateTo],
        "address.city": $city
      ) {
        id
        name {
          given
          family
        }
        birthDate
        gender
        address {
          city
          state
        }
      }
    }
  `;
  
  const result = await executeGraphQLQuery(query, params);
  return result.data.PatientList;
}
```

## Query Federation

GraphQL federation allows you to combine multiple GraphQL schemas into a unified API. This is particularly useful when integrating FHIR data with other systems.

### Setting Up Federation

```typescript
import { ApolloServer } from 'apollo-server';
import { ApolloGateway } from '@apollo/gateway';

// Create a gateway that combines multiple services
const gateway = new ApolloGateway({
  serviceList: [
    { name: 'fhir', url: 'http://localhost:8888/graphql' },
    { name: 'auth', url: 'http://localhost:4001/graphql' },
    { name: 'analytics', url: 'http://localhost:4002/graphql' }
  ]
});

// Initialize the ApolloServer with the gateway
const server = new ApolloServer({
  gateway,
  subscriptions: false // Federation doesn't support subscriptions yet
});

server.listen().then(({ url }) => {
  console.log(`ðŸš€ Gateway ready at ${url}`);
});
```

### Example Federated Query

```graphql
query GetPatientWithAuthAndAnalytics {
  # From FHIR service
  Patient(id: "123") {
    id
    name {
      given
      family
    }
    # From Auth service
    userPermissions {
      canEdit
      canView
      roles
    }
    # From Analytics service
    metrics {
      visitCount
      lastVisitDate
      riskScore
    }
  }
}
```

## Performance Considerations

### Query Complexity

GraphQL queries can become complex and potentially impact performance. Consider implementing query complexity analysis:

```typescript
import { ApolloServer } from 'apollo-server';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { createComplexityLimitRule } from 'graphql-validation-complexity';

const schema = makeExecutableSchema({
  typeDefs,
  resolvers
});

const server = new ApolloServer({
  schema,
  validationRules: [
    createComplexityLimitRule(1000, {
      onCost: (cost) => {
        console.log('Query cost:', cost);
      },
      formatErrorMessage: (cost) => {
        return `Query complexity (${cost}) is too high. Maximum allowed complexity is 1000.`;
      }
    })
  ]
});
```

### Batching and Caching

Implement DataLoader for efficient batching and caching:

```typescript
import DataLoader from 'dataloader';
import { AidboxClient } from '@aidbox/sdk-r4';

class FhirDataSource {
  private client: AidboxClient;
  private patientLoader: DataLoader<string, any>;
  
  constructor() {
    this.client = new AidboxClient({
      baseUrl: 'http://localhost:8888',
      auth: {
        type: 'basic',
        username: 'root',
        password: 'secret'
      }
    });
    
    // Create a DataLoader for batching Patient requests
    this.patientLoader = new DataLoader(async (ids: string[]) => {
      const query = `
        query GetMultiplePatients {
          ${ids.map((id, index) => `
            patient${index}: Patient(id: "${id}") {
              id
              name {
                given
                family
              }
              birthDate
              gender
            }
          `).join('')}
        }
      `;
      
      const result = await this.client.request({
        method: 'POST',
        url: '/graphql',
        data: { query }
      });
      
      // Return patients in the same order as the requested ids
      return ids.map((id, index) => result.data[`patient${index}`]);
    });
  }
  
  async getPatient(id: string): Promise<any> {
    return this.patientLoader.load(id);
  }
}
```

### Query Optimization

Use query optimization techniques to improve performance:

```typescript
import { ApolloServer } from 'apollo-server';
import responseCachePlugin from 'apollo-server-plugin-response-cache';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    responseCachePlugin({
      // Cache responses for up to 5 minutes
      defaultMaxAge: 300,
      // Don't cache errors
      shouldReadFromCache: ({ request, response }) => !response.errors,
      // Cache based on the operation and variables
      cache: new RedisCache({
        host: 'redis-server',
        port: 6379
      })
    })
  ]
});
```

## Example Implementations

### React Component with GraphQL

```typescript
import React, { useState, useEffect } from 'react';
import { AidboxClient } from '@aidbox/sdk-r4';

interface PatientDetailsProps {
  patientId: string;
}

const client = new AidboxClient({
  baseUrl: 'http://localhost:8888',
  auth: {
    type: 'basic',
    username: 'root',
    password: 'secret'
  }
});

const PatientDetails: React.FC<PatientDetailsProps> = ({ patientId }) => {
  const [patient, setPatient] = useState<any>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const fetchPatient = async () => {
      try {
        setLoading(true);
        
        const query = `
          query GetPatientWithRelatedData($id: ID!) {
            Patient(id: $id) {
              id
              name {
                given
                family
              }
              birthDate
              gender
              address {
                line
                city
                state
                postalCode
              }
              ObservationList(subject: $id, _count: 5) {
                id
                code {
                  coding {
                    display
                  }
                }
                valueQuantity {
                  value
                  unit
                }
                effectiveDateTime
              }
            }
          }
        `;
        
        const response = await client.request({
          method: 'POST',
          url: '/graphql',
          data: {
            query,
            variables: { id: patientId }
          }
        });
        
        setPatient(response.data.Patient);
        setError(null);
      } catch (err: any) {
        setError(err.message || 'Failed to fetch patient data');
      } finally {
        setLoading(false);
      }
    };
    
    fetchPatient();
  }, [patientId]);
  
  if (loading) return <div>Loading patient data...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!patient) return <div>No patient found</div>;
  
  const fullName = patient.name?.[0] ? 
    `${patient.name[0].given?.join(' ') || ''} ${patient.name[0].family || ''}`.trim() : 
    'Unknown';
  
  return (
    <div className="patient-details">
      <h2>{fullName}</h2>
      <div className="patient-info">
        <p><strong>Birth Date:</strong> {patient.birthDate || 'Unknown'}</p>
        <p><strong>Gender:</strong> {patient.gender || 'Unknown'}</p>
        
        {patient.address?.[0] && (
          <div className="address">
            <h3>Address</h3>
            <p>{patient.address[0].line?.join(', ')}</p>
            <p>{patient.address[0].city}, {patient.address[0].state} {patient.address[0].postalCode}</p>
          </div>
        )}
      </div>
      
      {patient.ObservationList?.length > 0 && (
        <div className="observations">
          <h3>Recent Observations</h3>
          <ul>
            {patient.ObservationList.map((obs: any) => (
              <li key={obs.id}>
                <p>
                  <strong>{obs.code?.coding?.[0]?.display || 'Observation'}:</strong>
                  {obs.valueQuantity ? 
                    ` ${obs.valueQuantity.value} ${obs.valueQuantity.unit}` : 
                    ' No value recorded'}
                </p>
                <p className="date">{new Date(obs.effectiveDateTime).toLocaleDateString()}</p>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

export default PatientDetails;
```

### Node.js Express Server with GraphQL Proxy

```typescript
import express from 'express';
import { createProxyMiddleware } from 'http-proxy-middleware';
import { AidboxClient } from '@aidbox/sdk-r4';

const app = express();
const PORT = 3000;

// Create Aidbox client for authentication
const aidboxClient = new AidboxClient({
  baseUrl: 'http://localhost:8888',
  auth: {
    type: 'basic',
    username: 'root',
    password: 'secret'
  }
});

// Middleware to authenticate requests
app.use(async (req, res, next) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Authorization header required' });
    }
    
    // Verify token with Aidbox
    // This is a simplified example - implement proper token verification
    const tokenValid = true; // Replace with actual verification
    
    if (!tokenValid) {
      return res.status(401).json({ error: 'Invalid token' });
    }
    
    next();
  } catch (error) {
    res.status(500).json({ error: 'Authentication error' });
  }
});

// Create GraphQL proxy
app.use('/graphql', createProxyMiddleware({
  target: 'http://localhost:8888',
  changeOrigin: true,
  pathRewrite: {
    '^/graphql': '/graphql'
  },
  onProxyReq: (proxyReq, req, res) => {
    // Add authentication to proxied request
    proxyReq.setHeader('Authorization', 'Basic ' + Buffer.from('root:secret').toString('base64'));
  }
}));

// Start server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## Conclusion

Integrating GraphQL with FHIR provides a powerful way to query healthcare data with greater flexibility and efficiency. By using GraphQL, you can:

1. Reduce the amount of data transferred over the network
2. Fetch complex, nested data structures in a single request
3. Enable clients to request exactly the data they need
4. Combine FHIR data with other systems through federation

The examples in this guide demonstrate how to set up GraphQL with Aidbox, create efficient queries, and implement best practices for performance optimization. By following these patterns, you can build more responsive and efficient healthcare applications.
